(Module [(Pass) (Break) (Continue) (Raise () ()) (Raise (Call (Name NameError Load) [(ConstantStr "String" ())] []) ()) (Raise (Name RuntimeError Load) (Name exc Load)) (Assert (Compare (Call (Name len Load) [(Name marks Load)] []) NotEq [(ConstantInt 0 ())]) (ConstantStr "List is empty." ())) (Assert (Compare (Name x Load) Eq [(ConstantStr "String" ())]) ()) (Assign [(Name x Store)] (ConstantInt 1 ()) ()) (Assign [(Tuple [(Name x Store) (Name y Store)] Store)] (Call (Name x Load) [] []) ()) (Assign [(Name x Store) (Name y Store)] (ConstantInt 1 ()) ()) (Assign [(Tuple [(Name x Store) (Name y Store)] Store)] (Tuple [(ConstantInt 1 ()) (ConstantInt 2 ())] Store) ()) (Assign [(Subscript (Name x Load) (Name i Load) Store)] (Tuple [(ConstantInt 1 ()) (ConstantInt 2 ())] Store) ()) (AugAssign (Name x Store) Add (ConstantInt 1 ())) (AnnAssign (Name x Store) (Name i64 Load) () 1) (AnnAssign (Name y Store) (Name i32 Load) (ConstantInt 1 ()) 1) (Delete [(Name x Del)]) (Delete [(Name x Del) (Name y Del)]) (Return ()) (Return (BinOp (Name a Load) Add (Name b Load))) (Return (Call (Name x Load) [(Name a Load)] [])) (Return (Tuple [(Name x Store) (Name y Store)] Store)) (Global [a]) (Global [a b]) (Nonlocal [a]) (Nonlocal [a b]) (Expr (ConstantInt 123 ())) (Expr (UnaryOp USub (ConstantInt 123 ()))) (Expr (UnaryOp USub (ConstantInt 291 ()))) (Expr (ConstantInt 6844 ())) (Expr (UnaryOp USub (ConstantInt 83 ()))) (Expr (ConstantInt 87 ())) (Expr (UnaryOp USub (ConstantInt 13 ()))) (Expr (ConstantInt 13 ())) (Expr (ConstantFloat 123.000000 ())) (Expr (ConstantFloat 123.450000 ())) (Expr (ConstantFloat 123400000000.000000 ())) (Expr (BinOp (ConstantInt 12 ()) Add (ConstantComplex 0.000000 3.000000 ()))) (Expr (BinOp (ConstantFloat 0.120000 ()) Add (ConstantComplex 0.000000 0.001000 ()))) (Expr (ConstantStr "String" ())) (Expr (ConstantBool .true. ())) (Expr (ConstantBool .false. ())) (Expr (BinOp (BinOp (Name x Load) Add (Name y Load)) Mult (Name z Load))) (Expr (BinOp (Name x Load) Sub (Name y Load))) (Expr (BinOp (Name x Load) Mult (Name y Load))) (Expr (BinOp (Name x Load) Div (Name y Load))) (Expr (BinOp (Name x Load) Mod (Name y Load))) (Expr (UnaryOp USub (Name y Load))) (Expr (UnaryOp UAdd (Name y Load))) (Expr (UnaryOp Invert (Name y Load))) (Expr (BinOp (Name x Load) Pow (Name y Load))) (Expr (BinOp (Name x Load) FloorDiv (Name y Load))) (Expr (BinOp (Name x Load) MatMult (Name y Load))) (Expr (BinOp (Name x Load) BitAnd (Name y Load))) (Expr (BinOp (Name x Load) BitOr (Name y Load))) (Expr (BinOp (Name x Load) BitXor (Name y Load))) (Expr (BinOp (Name x Load) LShift (Name y Load))) (Expr (BinOp (Name x Load) RShift (Name y Load))) (Expr (Compare (Name x Load) Eq [(Name y Load)])) (Expr (Compare (Name x Load) NotEq [(Name y Load)])) (Expr (Compare (Name x Load) Lt [(Name y Load)])) (Expr (Compare (Name x Load) LtE [(Name y Load)])) (Expr (Compare (Name x Load) Gt [(Name y Load)])) (Expr (Compare (Name x Load) GtE [(Name y Load)])) (AnnAssign (Name i Store) (Name i32 Load) (ConstantInt 4 ()) 1) (If (Compare (ConstantInt 2 ()) Gt [(Name i Load)]) [(Pass)] []) (If (Compare (Name i Load) Gt [(ConstantInt 5 ())]) [(Break)] []) (If (BoolOp And [(Compare (Name i Load) Eq [(ConstantInt 5 ())]) (Compare (Name i Load) Lt [(ConstantInt 10 ())])]) [(Assign [(Name i Store)] (ConstantInt 3 ()) ())] []) (For (Name i Store) (Call (Name range Load) [(Name N Load)] []) [(Assign [(Subscript (Name c Load) (Name i Load) Store)] (BinOp (Subscript (Name a Load) (Name i Load) Load) Add (BinOp (Name scalar Load) Mult (Subscript (Name b Load) (Name i Load) Load))) ())] [] ()) (Assign [(Name x Store)] (NamedExpr (Name y Store) (ConstantInt 0 ())) ()) (If (NamedExpr (Name a Store) (Call (Name ord Load) [(ConstantStr "3" ())] [])) [(Assign [(Name x Store)] (ConstantInt 1 ()) ())] []) (Assign [(Name a Store)] (Set [(ConstantInt 1 ()) (ConstantInt 2 ()) (ConstantInt 3 ())]) ())] [])
